return(easn)
}
# iterative search of censored repetitive plans
#start<-single.des(c(risks[1],risks[2]),c(p[1],p[2]),asvar)
found<-FALSE
des<-list()
n<-des.up$n
pb <- txtProgressBar(min = 0, max = n, style = 3)
while(!found) {
kaprox<- kval.aprox(n,risks,p,asvar)
k <- c(kaprox$kr,kaprox$ka)
sol<-nleqslv::nleqslv(k, risks.cond, control=list(ftol=.0001, allowSingular=TRUE),jacobian=TRUE,
method="Newton",n=n,risks=risks,p=p,beta.pars=beta.pars,asvar=asvar)
if( (sol$x[1]<sol$x[2]) & (n>1) ) {
des<-append(des,list(data.frame(q=asvar$q,n=n,n_low=des.low$n,n_up=des.up$n,
ka=sol$x[1],kr=sol$x[2],
termcd=sol$termcd,message=sol$message,
p_alpha=p[1],p_beta=p[2],dist=asvar$dist,
a=beta.pars$a,b=beta.pars$b,l=beta.pars$l,u=beta.pars$u,
mean_p=beta.pars$mean,
var_p=beta.pars$var_p,
dist=asvar$dist)))
}
n<-n-1
if(n<4) found<-TRUE
setTxtProgressBar(pb, des.up$n-n)
}
close(pb)
des<-do.call(rbind,des) %>% rowwise() %>%
mutate(
alpha=expected.risk(n,c(ka, kr),p_alpha,beta.pars,asvar,type="prod"),
beta=expected.risk(n,c(ka, kr),p_alpha,beta.pars,asvar,type="cons"),
asn_alpha=asn.curve(n,c(ka,kr),p_alpha,asvar),
asn_beta=asn.curve(n,c(ka,kr),p_beta,asvar),
asn_avg=sum(asn_alpha,asn_beta)*0.5,
easn=easn.curve(n,c(ka,kr),beta.pars,asvar)) %>%
mutate(p_asn_max=asn.max(n,c(ka,kr),c(p_alpha,p_beta),asvar),
asn_max=asn.curve(n,c(ka,kr),p_asn_max,asvar)) %>%
as.data.frame()
return(des)
}
repet.plan.prior(risks,p,beta.pars,asvar)
des<-repet.plan.prior(risks,p,beta.pars,asvar)
des %>% filter( (abs(alpha-risks[1])<1e-05) & (abs(beta-risks[2])<1e-05) & (termcd==1)) %>%
group_by(q,p_alpha,p_beta,a,b,c,d,dist) %>%
mutate(easn_min=min(easn)) %>%
slice(which.min(easn))
des %>% filter( (abs(alpha-risks[1])<1e-05) & (abs(beta-risks[2])<1e-05) & (termcd==1)) %>%
group_by(q,p_alpha,p_beta,a,b,l,u,dist) %>%
mutate(easn_min=min(easn)) %>%
slice(which.min(easn))
des %>% filter( (abs(alpha-risks[1])<1e-05) & (abs(beta-risks[2])<1e-05) & (termcd==1)) %>%
group_by(q,p_alpha,p_beta,a,b,l,u,dist) %>%
mutate(easn_min=min(easn))
View(des)
des %>% filter( (abs(alpha-risks[1])<1e-05) & (abs(beta-risks[2])<1e-05) & (termcd==1)) %>%
group_by(q,p_alpha,p_beta,a,b,l,u,dist) %>%
mutate(easn_min=min(easn))
des %>% filter( (abs(alpha-risks[1])<1e-05) & (abs(beta-risks[2])<1e-05) & (termcd==1))
risks
## design of repetitive plan with expected risks
repet.plan.prior<-function(risks,p,beta.pars,asvar) {
repet.design <-function(risks,p,asvar) {
tol<-1e-05
start<-repet.plan(risks,p,asvar)
start<-start %>% filter( (abs(alpha-risks[1])<tol) & (abs(risks[2]-beta)<tol) & (termcd==1))
start_low<-start %>% slice(which.min(n)) %>% as.data.frame()
start_up<-start %>% slice(which.max(n)) %>% as.data.frame()
return(list(low=start_low[,c("n","ka","kr")],up=start_up[,c("n","ka","kr")]))
}
des.up<-repet.design(risks,c(p[1],p[2]),asvar)$up
des.low<-if(beta.pars$l>0 & beta.pars$u<1) repet.design(risks,c(beta.pars$l,beta.pars$u),asvar)$low else data.frame(n=2,ka=NaN,kr=NaN)
expected.risk<-function(n,k,p,beta.pars,asvar,type) {
tol <- 1e-10
func_prod<- function(arg1) {
integrate(function(t) (1-oc.curve(n,k,t,asvar))*gentrunc.beta.pdf(t,beta.pars$a,beta.pars$b,beta.pars$l,beta.pars$u),
lower = beta.pars$l+tol, upper = arg1)$value/gentrunc.beta.cdf(arg1,beta.pars$a,beta.pars$b,beta.pars$l,beta.pars$u)
}
risk_prod<-Vectorize(func_prod, vectorize.args='arg1')
func_cons<- function(arg1) {
integrate(function(t) oc.curve(n,k,t,asvar)*gentrunc.beta.pdf(t,beta.pars$a,beta.pars$b,beta.pars$l,beta.pars$u),
lower = arg1, upper = beta.pars$u)$value/(1-gentrunc.beta.cdf(arg1,beta.pars$a,beta.pars$b,beta.pars$l,beta.pars$u))
}
risk_cons<-Vectorize(func_cons, vectorize.args='arg1')
switch(type,
prod=risk_prod(p),
cons=risk_cons(p))
}
# function to compute expected sampling risks
risks.cond <- function(x,n,risks,p,beta.pars,asvar) {
cond<-c(expected.risk(n,c(x[1], x[2]),p[1],beta.pars,asvar,type="prod"),
expected.risk(n,c(x[1], x[2]),p[2],beta.pars,asvar,type="cons")) - c(risks[1],risks[2])
cond
}
#function to compute the expected ASN
easn.curve<-function(n,k,beta.pars,asvar) {
easn<-tryCatch({
integrate(function(t) asn.curve(n,k,t,asvar)*gentrunc.beta.pdf(t,beta.pars$a,beta.pars$b,beta.pars$l,beta.pars$u),
lower = beta.pars$l, upper = beta.pars$u)$value
},
error=function(e) return(NA)
)
return(easn)
}
# iterative search of censored repetitive plans
#start<-single.des(c(risks[1],risks[2]),c(p[1],p[2]),asvar)
found<-FALSE
des<-list()
n<-des.up$n
pb <- txtProgressBar(min = 0, max = n, style = 3)
while(!found) {
kaprox<- kval.aprox(n,risks,p,asvar)
k <- c(kaprox$kr,kaprox$ka)
sol<-nleqslv::nleqslv(k, risks.cond, control=list(ftol=.0001, allowSingular=TRUE),jacobian=TRUE,
method="Newton",n=n,risks=risks,p=p,beta.pars=beta.pars,asvar=asvar)
if( (sol$x[1]<sol$x[2]) & (n>1) ) {
des<-append(des,list(data.frame(q=asvar$q,n=n,n_low=des.low$n,n_up=des.up$n,
ka=sol$x[1],kr=sol$x[2],
termcd=sol$termcd,message=sol$message,
p_alpha=p[1],p_beta=p[2],
a=beta.pars$a,b=beta.pars$b,l=beta.pars$l,u=beta.pars$u,
mean_p=beta.pars$mean,
var_p=beta.pars$var_p,
dist=asvar$dist)))
}
n<-n-1
if(n<2) found<-TRUE
setTxtProgressBar(pb, des.up$n-n)
}
close(pb)
des<-do.call(rbind,des) %>% rowwise() %>%
mutate(
alpha=expected.risk(n,c(ka, kr),p_alpha,beta.pars,asvar,type="prod"),
beta=expected.risk(n,c(ka, kr),p_beta,beta.pars,asvar,type="cons"),
asn_alpha=asn.curve(n,c(ka,kr),p_alpha,asvar),
asn_beta=asn.curve(n,c(ka,kr),p_beta,asvar),
asn_avg=sum(asn_alpha,asn_beta)*0.5,
easn=easn.curve(n,c(ka,kr),beta.pars,asvar)) %>%
mutate(p_asn_max=asn.max(n,c(ka,kr),c(p_alpha,p_beta),asvar),
asn_max=asn.curve(n,c(ka,kr),p_asn_max,asvar)) %>%
as.data.frame()
return(des)
}
des<-repet.plan.prior(risks,p,beta.pars,asvar)
des %>% filter( (abs(alpha-risks[1])<1e-05) & (abs(beta-risks[2])<1e-05) & (termcd==1)) %>%
group_by(q,p_alpha,p_beta,a,b,l,u,dist) %>%
mutate(easn_min=min(easn)) %>%
slice(which.min(easn))
des %>% filter( (abs(alpha-risks[1])<1e-05) & (abs(beta-risks[2])<1e-05) & (termcd==1)) %>%
group_by(q,p_alpha,p_beta,a,b,l,u,dist) %>%
mutate(easn_min=min(easn)) %>%
slice(which.min(easn)) %>% as.data.frame()
beta.pars
des
#' q<- 0.1
#' asvar<-asympt.var(q,"normal")
#' l<- p[1]/5
#' u<- p[2]+(p[1]-l)
#'
#' # knowledge of mean and variance of p distribution
#' know_p<-list(mean_p=p[1],var_p=((p[2]-p[1])/4)^2)
#' beta.parms<-beta.params(p,l,u, know_p)
#'
#' repGBprior.plan(risks,p,asvar, beta.parms)
repGBprior.plan<-function(risks,p,asvar,beta.pars) {
# function to compute lower and upper bounds of n
bounds.n <-function(risks,p,asvar) {
tol<-1e-05
start<-repet.plan(risks,p,asvar)
start<-start %>% filter( (abs(alpha-risks[1])<tol) & (abs(risks[2]-beta)<tol) & (termcd==1))
start_low<-start %>% slice(which.min(n)) %>% as.data.frame()
start_up<-start %>% slice(which.max(n)) %>% as.data.frame()
return(list(low=start_low[,c("n","ka","kr")],up=start_up[,c("n","ka","kr")]))
}
n.up<-bounds.n(risks,c(p[1],p[2]),asvar)$up
n.low<-if(beta.pars$l>0 & beta.pars$u<1) bounds.n(risks,c(beta.pars$l,beta.pars$u),asvar)$low else data.frame(n=2,ka=NaN,kr=NaN)
# function to compute expected sampling risks
expected.risk<-function(n,k,p,beta.pars,asvar,type) {
tol <- 1e-10
func_prod<- function(arg1) {
integrate(function(t) (1-oc.curve(n,k,t,asvar))*gentrunc.beta.pdf(t,beta.pars$a,beta.pars$b,beta.pars$l,beta.pars$u),
lower = beta.pars$l+tol, upper = arg1)$value/gentrunc.beta.cdf(arg1,beta.pars$a,beta.pars$b,beta.pars$l,beta.pars$u)
}
risk_prod<-Vectorize(func_prod, vectorize.args='arg1')
func_cons<- function(arg1) {
integrate(function(t) oc.curve(n,k,t,asvar)*gentrunc.beta.pdf(t,beta.pars$a,beta.pars$b,beta.pars$l,beta.pars$u),
lower = arg1, upper = beta.pars$u)$value/(1-gentrunc.beta.cdf(arg1,beta.pars$a,beta.pars$b,beta.pars$l,beta.pars$u))
}
risk_cons<-Vectorize(func_cons, vectorize.args='arg1')
switch(type,
prod=risk_prod(p),
cons=risk_cons(p))
}
# function to compute ka, kr verifying the maximum expected sampling risks
risks.cond <- function(x,n,risks,p,beta.pars,asvar) {
cond<-c(expected.risk(n,c(x[1], x[2]),p[1],beta.pars,asvar,type="prod"),
expected.risk(n,c(x[1], x[2]),p[2],beta.pars,asvar,type="cons")) - c(risks[1],risks[2])
cond
}
#function to compute the expected ASN
easn.curve<-function(n,k,beta.pars,asvar) {
easn<-tryCatch({
integrate(function(t) asn.curve(n,k,t,asvar)*gentrunc.beta.pdf(t,beta.pars$a,beta.pars$b,beta.pars$l,beta.pars$u),
lower = beta.pars$l, upper = beta.pars$u)$value
},
error=function(e) return(NA)
)
return(easn)
}
#iterative search of censored repetitive plans
found<-FALSE
des<-list()
n<-n.up$n
pb <- txtProgressBar(min = 0, max = n, style = 3)
while(!found) {
kaprox<- kval.aprox(n,risks,p,asvar)
k <- c(kaprox$kr,kaprox$ka)
sol<-nleqslv::nleqslv(k, risks.cond, control=list(ftol=.0001, allowSingular=TRUE),jacobian=TRUE,
method="Newton",n=n,risks=risks,p=p,beta.pars=beta.pars,asvar=asvar)
if( (sol$x[1]<sol$x[2]) & (n>1) ) {
des<-append(des,list(data.frame(q=asvar$q,n=n,n_low=n.low$n,n_up=n.up$n,
kr=sol$x[1],ka=sol$x[2],
termcd=sol$termcd,message=sol$message,
p_alpha=p[1],p_beta=p[2],
a=beta.pars$a,b=beta.pars$b,l=beta.pars$l,u=beta.pars$u,
mean_p=beta.pars$mean,
var_p=beta.pars$var_p,
dist=asvar$dist)))
}
n<-n-1
if(n<2) found<-TRUE
setTxtProgressBar(pb, n.up$n-n)
}
close(pb)
des<-do.call(rbind,des) %>% rowwise() %>%
mutate(
alpha=expected.risk(n,c(kr, ka),p_alpha,beta.pars,asvar,type="prod"),
beta=expected.risk(n,c(kr, ka),p_beta,beta.pars,asvar,type="cons"),
asn_alpha=asn.curve(n,c(kr,ka),p_alpha,asvar),
asn_beta=asn.curve(n,c(kr,ka),p_beta,asvar),
asn_avg=sum(asn_alpha,asn_beta)*0.5,
easn=easn.curve(n,c(kr,ka),beta.pars,asvar)) %>%
mutate(p_asn_max=asn.max(n,c(kr,ka),c(p_alpha,p_beta),asvar),
asn_max=asn.curve(n,c(kr,ka),p_asn_max,asvar)) %>%
as.data.frame()
return(des)
}
know_p<-list(mean_p=p[1],var_p=((p[2]-p[1])/4)^2)
beta.parms<-beta.params(p,l,u, know_p)
repGBprior.plan(risks,p,asvar, beta.parms)
designs<-repGBprior.plan(risks,p,asvar, beta.parms)
optimal.design<-designs %>% group_by(q,dist,p_alpha,p_beta) %>%
filter( (abs(alfa-risks[1])<1e-05) & (abs(risks[2]-beta)<1e-05) & (termcd==1)) %>%
group_by(q,p_alpha,p_beta,a,b,l,u,dist) %>%
mutate(easn_min=min(easn)) %>%
slice(which.min(easn)) %>% as.data.frame()
optimal.design<-designs %>% group_by(q,dist,p_alpha,p_beta) %>%
filter( (abs(alpha-risks[1])<1e-05) & (abs(risks[2]-beta)<1e-05) & (termcd==1)) %>%
group_by(q,p_alpha,p_beta,a,b,l,u,dist) %>%
mutate(easn_min=min(easn)) %>%
slice(which.min(easn)) %>% as.data.frame()
optimal.design
devtools::document()
devtools::document()
rm(list = c("asn.max", "beta.params", "gentrunc.beta.cdf", "gentrunc.beta.pdf", "kval.aprox", "repGBprior.plan"))
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
library(tools)
Rd2HTML("man/beta.params.Rd")
Rd2HTML("man/beta.params.Rd",out="ejem.html")
usethis::use_roxygen_md()
devtools::document()
?beta.params
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
?oc.curve
devtools::document()
?oc.curve
?asn.curve
?invprob
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
devtools::document()
?beta.params
install.packages("mathjaxr")
devtools::document()
?example
library(mathjaxr)
devtools::document(roclets = c('rd', 'collate', 'namespace')))
devtools::document(roclets = c('rd', 'collate', 'namespace'))
?example
preview_rd("example.Rd")
.rs.restartR()
?beta.params
devtools::document(roclets = c('rd', 'collate', 'namespace'))
?beta.params
warnings()
?beta.params
devtools::document(roclets = c('rd', 'collate', 'namespace'))
?beta.params
devtools::install()
?beta.params
library(RepetPlan)
?beta.params
devtools::install()
devtools::document()
devtools::install()
help(package="RepetPlan")
?RepetPlan
library(flexdashboard)
des
library(flexdashboard)
set_flextable_defaults(big.mark = " ",
font.size = 10, theme_fun = theme_vanilla,
padding.bottom = 6,
padding.top = 6,
padding.left = 6,
padding.right = 6,
background.color = "#EFEFEF")
flextable(des)
library(flextable)
install.packages("flextable")
library(flextable)
set_flextable_defaults(big.mark = " ",
font.size = 10, theme_fun = theme_vanilla,
padding.bottom = 6,
padding.top = 6,
padding.left = 6,
padding.right = 6,
background.color = "#EFEFEF")
flextable(des)
library(RepetPlan)
?rep.plan
devtools::document()
?rep.plan
devtools::install()
?rep.plan
help(package="RepetPlan")
?oc.curve
devtools::document()
devtools::install()
help(package="RepetPlan")
?asn.curve
devtools::install()
library(RepetPlan)
help(package="RepetPlan")
re.plan
rep.plan
?rep.plan
risks<-c(0.05,0.10)
p<-c(0.00654, 0.0426)
q<- 0.1
asvar<-asympt.var(q,"normal")
designs<-rep.plan(risks,p,asvar
)
kval.aprox
rep
designs<-rep(risks,p,asvar)
rep.plan
?repGBprior.plan
repGBprior.plan
devtools::document()
?rep.plan
devtools::document()
devtools::document()
?rep.plan
?repe.plan
devtools::document()
devtools::document()
?rep.plan
rep.plan
devtools::install()
?rep.plan
help(package="RepetPlan")
devtools::install()
library(RepetPlan)
?rep.plan
library(flextable)
risks<-c(0.05,0.10)     #vector of producer and consumer maximum sampling risks
p<-c(0.00654, 0.0426)   #vector of acceptance and rejection quality levels
q<- 0.1                 #censoring degree
asvar<-asympt.var(q,"normal")    #asymptotical variance-covariance matrix of MLE estimators of location and scale paramters
designs<-rep.plan(risks,p,asvar) #designs satisfying the previous requirements
set_flextable_defaults(big.mark = " ",
font.size = 10, theme_fun = theme_vanilla,
padding.bottom = 6,
padding.top = 6,
padding.left = 6,
padding.right = 6,
background.color = "#EFEFEF")
flextable(designs)
webshot::install_phantomjs()
tab<-flextable(designs)
knitr::knit_print(tab)
data<-regulartable(head(iris))
data
unlink('README_cache', recursive = TRUE)
knit_with_parameters('E:/docencia_investigacion/R/repetplan/README.Rmd')
knitr::opts_chunk$set(echo = TRUE)
kbl(head(iris)) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
library(dplyr)
kbl(head(iris)) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
knitr::kbl(head(iris)) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
library(kableExtra)
install.packages("kableExtra")
library(kableExtra)
knitr::kbl(head(iris)) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
kbl(head(iris)) %>%
kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
beta.parms
?repGBprior.plan
risks<-c(0.05,0.10)
p<-c(0.00654, 0.0426)
q<- 0.1
asvar<-asympt.var(q,"normal")
l<- p[1]/5
u<- p[2]+(p[1]-l)
# knowledge of mean and variance of p distribution
know_p<-list(mean_p=p[1],var_p=((p[2]-p[1])/4)^2)
beta.parms<-beta.params(p,l,u, know_p)
designs<-repGBprior.plan(risks,p,asvar, beta.parms)
devtools::install()
designs<-repGBprior.plan(risks,p,asvar, beta.parms)
devtools::document()
designs<-rep.plan(risks,p,asvar)
designs<-rep.plan(risks,p,asvar)
devtools::document()
designs<-rep.plan(risks,p,asvar)
designs
devtools::document()
designs<-rep.plan(risks,p,asvar)
devtools::document()
designs<-rep.plan(risks,p,asvar)
# install.packages("progress")
library(progress)
n_iter <- 100
pb <- progress_bar$new(format = "(:spin) [:bar] :percent [Tiempo transcurrido: :elapsedfull || Tiempo restante estimado: :eta]",
total = n_iter,
complete = "=",   # Caracteres de las iteraciones finalizadas
incomplete = "-", # Caracteres de las iteraciones no finalizadas
current = ">",    # Caracter actual
clear = FALSE,    # Si TRUE, borra la barra cuando termine
width = 100)      # Ancho de la barra de progreso
for(i in 1:n_iter) {
# Actualiza el estado actual
pb$tick()
#-------------------
# Aquí va tu código:
#-------------------
Sys.sleep(0.1) # Borra esta línea y añade tu código
#-------------------
}
devtools::document()
designs<-rep.plan(risks,p,asvar)
devtools::document()
devtools::install()
